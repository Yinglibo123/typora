# JAVA内存区域与内存溢出异常

java可以在虚拟机自动进行内存管理，不需要手动的free和delete，不容易出现内存溢出的问题。

## 运行时数据区域

<img src="./image/截屏2023-09-20 17.48.16.png" alt="截屏2023-09-20 17.48.16" style="zoom: 50%;" />

### 程序计数器

一小块内存空间，可以看成当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器，各线程之间的程序计数器互不影响，独立存储，称这类内存区域为“==线程私有==”的内存。

如果线程执行的是一个JAVA方法，该计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是本地方法，这个计数器的值为空(Undefined)。==该内存区域是唯一一个不会出现OutOfMemeoryError情况的区域==。

### java虚拟机栈

线程私有，生命周期和线程一样

该区域描述的是JAVA方法执行的线程内存模型：每个方法被执行的时候，JAVA虚拟机会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

局部变量表：

- 存放编译期可知的任何JAVA虚拟机基本数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型，是一个指向对象起始地址的引用指针)、returnAddress类型（指向一条字节码指令的地址）

- 64位的long和double类型的数据在局部变量表中会占用两个变量槽，其余的占用一个。

- 局部变量表所需的内存在编译期间完成分配，在进入方法的时候，该方法在栈帧中需要分配的局部变量空间的大小是完全确定的，而且方法在运行的时候不会改变。（大小：变量槽的数量）

- 一个变量槽占用多少个字节是由虚拟机自行决定的。

两种异常情况：
- StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度
- OutOfMemoryError：栈扩展的时候无法申请到足够的内存

### 本地方法栈

- 与虚拟机栈的作用类似，不同的是本地方法栈是为虚拟机使用本地方法服务。
- 也有StackOverflowError与OutOfMemoryError异常。
- Java虚拟机规范对本地方法栈使用的语言、使用方法、数据结构都没有强制规定，可以根据具体虚拟机的需要自由实现。

### JAVA堆

- 是虚拟机管理的内存中最大的一块
- 被所有的线程共享的内存区域，在虚拟机启动的时候创建
- 作用：存放对象实例以及数组
- JAVA堆是由垃圾回收器管理的内存区域，所以也称为“GC堆”（Garbage Collected Heap）
- 为了提升分配对象分配内存、回收内存的效率，会将JAVA堆分为多个线程私有的分配缓冲区。
- JAVA堆可以处于物理上不连续的内存空间中，但是逻辑上是连续的。（数组对象通常放在连续的物理内存上）
- OutOfMemoryError异常：JAVA堆中没有内存完成实例分配，并且堆也无法扩展。

### 方法区

- 线程共享的内存区域
- 作用：存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
- 《JAVA虚拟机规范》对方法区的约束很宽松，不要求连续的物理内存，可以选择固定大小或者动态扩展，甚至可以选择不实现垃圾收集
- OutOfMemoryError异常

### 运行时常量池

- 是方法区的一部分
- 作用：存放编译器生成的各种字面量和符号引用
- 《JAVA虚拟机规范》没有任何的细节要求
- 具备动态性，运行期间新的常量也可以加入池中（String类的intern()方法）
- OutOfMemoryError异常

### 直接内存(Direct Memory)

- 不是虚拟机运行时数据区的一部分,但是也有OutOfMemoryError异常
- 直接内存的分配不会受到JAVA堆大小的限制，但是受到本机总内存（物理内存、SWAP分区、分页文件）大小、处理器寻址空间的限制，如果各内存区域总和大于物理内存限制，会导致动态扩展时出现OutOfMemoryError限制。
- NIO（jdk1.4），通过存储在JAVA堆中的DirectByteBuffer对象操作直接内存，访问直接内存的速度会优于Java堆。即读写性能高。
  1. 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存
  2. Java的NIO库允许Java程序使用直接内存，用于数据缓冲区

- **缺点**
  1. 分配回收成本高
  2. 不受JVM内存管理回收







## HotSpot虚拟机对象

### 对象的创建

*讨论的是普通的JAVA对象，不包含数组，Class对象*

**加载的过程：**

类加载--->虚拟机为对象分配内存（所需的大小在类加载完后就完全确定了）--->将分配到的内存空间（不包括对象头）初始化为零值--->JAVA虚拟机对对象进行必要的设置--->执行init方法进行对象初始化

**为对象分配内存的方式：**

- 指针碰撞：JAVA堆中内存是规整的时候，一边是使用过的内存，一边是未使用的内存，中间维护一个指针，当需要分配内存的时候，将指针向空闲方向移动对象所需大小的距离即可。（采用这种方法比较高效，但是要求使用的JAVA虚拟机的垃圾收集器带有空间压缩整理的能力）
- 空闲列表：JAVA堆中的内存不是规整的时候，虚拟机维护一个空闲列表，当需要分配空间的时候，可以查询该列表，找到一块足够大的空间分配给空间。

### 对象的内存布局

对象在堆中的存储布局可以划分为三个部分：对象头、实例数据、对齐填充

对象头：

- 对象自身运行时的数据（哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，在未开启指针压缩的32位和64位虚拟机中，这些数据的长度为32比特、64比特）、
- 类型指针：对象指向其类型元数据的指针，JAVA虚拟机通过该指针来确定该对象是哪个类的实例。（有的虚拟机中没有）

实例数据：

- 在程序代码中定义的各种类型的字段内容，包括父类继承下来的和子类中的

- 分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops，

- 在第二条的前提下，父类中定义的变量在子类之前

对齐填充：在HotSpot中虚拟机的自动内存管理系统要求对象的起始地址位8字节的整数倍，所以任何对象的大小都是8字节的整数倍，所以需要对齐填充。

### 对象的定位访问

==JAVA程序会通过栈上的reference数据来操作堆上的具体对象==

访问方式：

- 使用句柄访问：JAVA堆中划分一部分内存作为句柄池，reference中存储的是对象的句柄地址，句柄中包含对象实例数据与类型数据各自的地址
  - 优点：reference中存储的是稳定的句柄地址，在对象被移动的时候，只需要改变句柄中的实例数据指针，不需要改变reference
- 直接指针：reference中存储的是对象地址
  - 优点：速度更快，节省了一次指针定位的时间开销

<img src="./image/截屏2023-09-21 16.49.34.png" alt="截屏2023-09-21 16.49.34" style="zoom: 33%;" />



# 垃圾收集器与内存分配策略

为什么要了解垃圾收集和内存分配：当需要排除各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈的时候，需要对这些自动化完成的垃圾收集和内存分配技术实施必要的监控和调节。

JAVA内存运行时区域中，**程序计数器、虚拟机栈、本地方法栈**随着程序而生，随程序而灭，而且每一个栈帧分配多少内存是在编译器就知道的，分配和回收都具备了确定性，所以这几个区域不需要考虑垃圾回收的问题

**JAVA堆和方法区**具有很显著的不确定性，垃圾回收器需要关注这一部分的内存如何管理。（不确定性：一个接口多个实现类需要的内存不一样，一个方法执行不同条件的分支所需的内存也可能不一样，只有处于运行期间，才可以确定程序创建了多少个对象）

## 对象已死？

## 引用计数器&可达性分析算法

**判断对象是否存活，哪些已死（不可能再被任何途径使用的对象）：**

- 引用计数器：每当有一个地方引用的时候，计数值就加一；引用失效的时候，就减一。计数器为0的对象就是不可以再被使用的。
  - 优点：该方法原理简单，高效，
  - 缺点：单纯的引用计数器很难解决对象之间相互循环引用的问题
  
- 可达性分析算法（java、c#的内存管理系统判断对象是否存活都采用该算法）

  - 从根对象“GC Roots”出发，如果从根节点到目标对象节点不可达，就说明该对象不会再次被使用。

  <img src="./image/截屏2023-09-22 15.56.42.png" alt="截屏2023-09-22 15.56.42" style="zoom:33%;" />

JAVA中，可以固定作为GC Roots的对象包括：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象，比如各线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
- 方法区中类静态属性引用的对象，比如JAVA类的引用类型静态变量
- 方法区中常量引用的对象，比如字符串常量池里的引用
- 本地方法栈中JNI(本地方法)引用的对象
- Java虚拟机内部的引用，比如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointerException、OutOfMemoryError)，系统类加载器
- 所有被同步锁持有的对象
- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

可以临时加入GC Roots集合的：分代收集和局部回收

### 引用

Jdk1.2之前引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是某个内存、某个对象的引用。（这里的对象只有两种状态：被引用、未被引用）

Jdk1.2之后：将引用分为强引用、软引用、弱引用、虚引用 (引用强度依次递减)

- 强引用：代码中的引用赋值，类似"Object obj=new Object()"这种引用关系。垃圾回收器不会回收具有强引用关系的对象
- 软引用：描述一些还有些用，但是非必需的对象。在系统将要发生内存溢出异常前，会将这些对象列入回收范围之中。如果此次回收还是没有足够的内存，才会抛出内存溢出异常。
- 弱引用：只被弱引用关联的对象只能生存到下一次垃圾收集发生为止（不论内存是否足够）。
- 虚引用：一个对象是否存在弱引用，不会对其生存时间构成影响，也无法通过一个虚引用来获取一个对象实例，为一个对象设置虚引用的目的是：在这个对象被收集器回收时收到一个系统通知。

### 生存还是死亡？

当对象在可达性算法中被判定为不可达的时候，还需要判定此对象是否有必要执行finalize()方法。

**没有必要执行finalize()方法的情况**：

- 对象没有覆盖finalize()方法

- finalize()方法已经被虚拟机调用过(因为该方法只会被调用一次，所以这一次会被回收)

**如果有必要执行finalize()方法**，该对象会被放置在一个名为F-Queue的队列中，稍后由虚拟机创建自动建立的、低调度优先级的Finalizer线程去执行finalize()方法。如果对象在finalize()方法中重新建立起与引用链上任何一个对象之间的关系，那么会将该对象移出“即将回收”的集合；否则，该对象将会被回收。

==**该方法运行代价高，不确定性大，目前finalize()方法已经被抛弃了，不推荐使用**==

### 回收方法区

《java虚拟规范》中没有要求虚拟机在方法区中实现垃圾收集。

如果要实现方法区的垃圾回收，主要关注两部分的内容：**废弃的常量、不再使用的类型**。

判断是否回收常量：没有对象引用该常量

判断是否回收类型：

- 该类的所有实例已经被回收，不存在该类以及派生子类的实例
- 加载该类的类加载器已经被回收（很难达到）
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

## 垃圾回收算法

从对象消亡的角度来看，垃圾收集算法可以划分为：

- 引用计数式垃圾收集（直接垃圾收集）
- 追踪式垃圾收集（间接垃圾收集）

### 分代收集理论

该理论建立在分代假说之上：

- 弱分代假说：绝大多数的对象都是朝生夕灭
- 强分代假说：熬过越多次垃圾收集过程的对象就越难消亡
- 跨代引用假说：跨代引用相对于同代引用来说更少

由此得出了垃圾收集器的基本原则：收集器将JAVA堆划分为不同的区域，根据对象垃圾回收的次数将对象分配到不同的区域。

每次回收就可以只回收JAVA堆中的一部分区域------>回收类型的划分：Minor GC、Major GC、Full GC

可以针对不同的区域设计不同的垃圾收集算法------->垃圾收集算法：标记-赋值、标记-清除、标记-整理算法

可以将JAVA堆划分为：

- 新生代（每次垃圾回收时会有大量对象被回收，存活下来的逐步转移到老年代）
- 老年代

如果需要对新生代进行一次垃圾收集，由于新生代也可能被老年代引用，为了找出新生代可存活的对象，除了固定的GC Roots之外，还需要**额外遍历老年代中的所有对象来保证可达性分析结果的正确性**。这样做会为内存回收带来很大的性能负担。根据**分代假说的第三条**，不应该为少量的跨代引用扫描整个老年代，只需要在新生代上建立一个全局数据结构（记忆集），这个结构将老年代划分为若干个小块，标识出老年代的哪一块内存会存在跨代引用。

**几个定义：**

- 部分收集（partial GC）
  - 新生代收集（minor GC/young GC）:目标只是新生代的垃圾收集
  - 老年代收集（major GC/old GC）：目标是老年代的垃圾收集。目前只有CMS收集器有
  - 混合收集（mixed GC）:目标是整个新生代以及部分老年代的垃圾收集。目前只有G1收集器有
- 整堆收集（full GC）：收集整个JAVA堆和方法区的垃圾回收

### 标记-清除算法

最基础的垃圾回收算法

算法分为两个阶段：

- 标记（标记需要回收/存活的对象）

- 清除（清除标记/未标记的对象）

缺点：

- 执行的效率不稳定。如果java堆中含有大量的对象，且大部分需要被回收，产生大量标记、清除操作

- 内存空间碎片化问题。标记清除会导致大量的碎片，后面需要分配内存时就没有大片的连续空间，只能再次触发垃圾收集动作。（可以借助分区空闲分配链表来解决）

  ![截屏2023-09-23 21.35.43](/Users/yinglibo/Documents/typora/截屏2023-09-23 21.35.43.png)

### 标记-复制算法

将内存划分为两个大小相等的块，每次只使用其中的一块，当一块的内存用完了后，将还存活的对象复制到另外一边（移动堆顶的指针，顺序分配），然后将使用过的内存一次性清理掉。

缺点：代价是可用的内存缩小为原来的一半

<img src="./image/截屏2023-09-23 21.59.03.png" alt="截屏2023-09-23 21.59.03" style="zoom:50%;" />

Appel式回收：把新生代分为，一块较大的Eden空间、两块较小的Survivor空间（s1,s2）。

每次分配内存时只使用Eden和其中一块Survivor空间，发生垃圾收集时，将Eden和Survivor(s1)空间中存活的对象复制到另外一块Survivor空间(s2)，然后清理掉Eden和Survivor空间(s1)。

在普通的场景下，98%的新生代中的对象熬不过第一轮垃圾收集。HotSpot虚拟机分配Eden、s1、s2的空间的比例为8:1:1。如果s2的空间不足以容纳一次minor GC之后存活的对象，需要依赖其他内存区域（老年代）进行分配担保。

### 标记-整理算法

标记整理算法与标记清除算法的区别：前者是一种移动式的回收算法、后者是一种非移动式的。

将存活的对象都移向另外一边。

<img src="./image/截屏2023-09-23 22.22.25.png" alt="截屏2023-09-23 22.22.25" style="zoom:50%;" />

标记整理算法内存回收时更加复杂（特别是在老年代这种每次回收都有大量对象存活的区域），而且必须全程暂停用户程序；标记清除算法分配内存时更加复杂（可以通过分区空闲分配链表来解决内存分配问题），会影响应用程序的吞吐量。

一种中和的办法：平时采用标记清除算法（允许内存碎片存在），直到内存碎片化程度影响对象分配时，才采用标记整理算法收集一次，来获得连续的空间。

## HotSpot算法细节实现

==先跳过==



## 经典垃圾收集器

《java虚拟机规范》中对垃圾收集器如何实现没有任何规定。

几种经典的收集器之间的关系：

<img src="./image/截屏2023-09-25 17.00.27.png" alt="截屏2023-09-25 17.00.27" style="zoom: 50%;" />

如果收集器被连线连接在一起，说明这两个收集器可以搭配使用。上半部分是新生代收集器，下半部分是老年代的垃圾收集器。

### Serial收集器

新生代垃圾收集器

单线程工作（只会使用一个处理器或者一条收集线程完成垃圾收集工作。而且在进行垃圾回收的时候，会停止其他所有的工作线程，直到它收集结束。用户体验很差）

迄今为止，依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，优点是简单高效（与其他单线程收集器相比较），是所有收集器里额外内存消耗最小的，而且没有线程交互的开销。

<img src="./image/截屏2023-09-25 19.07.37.png" alt="截屏2023-09-25 19.07.37" style="zoom:50%;" />

### ParNew收集器

Serial收集器的并行版本，可以使用多条线程进行垃圾收集，除此之外两者完全一致

是很多运行在服务器端下的HotSpot虚拟采用的新生代收集器，在JDK7之前默认的新生代收集器（只有ParNew和Serial收集器可以与CMS收集器配合工作）

CMS收集器在JDK5发布时发布，是HotSpot虚拟机中第一款支持并发的垃圾收集器，首次实现了垃圾收集线程和用户线程（基本上）同时工作。

<img src="./image/截屏2023-09-25 19.15.46.png" alt="截屏2023-09-25 19.15.46" style="zoom:50%;" />

### Parallel Scavenge收集器

新生代收集器

基于标记-复制算法实现

可以并行收集的多线程收集器

CMS收集器的关注点：尽可能缩短垃圾收集时用户线程的停顿时间

Parallel Scavenge收集器的目标：达到一个可控的吞吐量

$吞吐量=\frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}$

### Serial Old收集器

是Serial收集器的老年代版本

单线程收集器

使用标记-整理算法

主要用途：供客户端模式下的HotSpot虚拟机使用

在服务器模式下：

- 在JDK5以及之前的版本和Parallel Scavenge收集器搭配使用

- 作为CMS收集器失败的后备方案

  <img src="./image/截屏2023-09-25 19.07.37.png" alt="截屏2023-09-25 19.07.37" style="zoom:50%;" />

### Parallel Old收集器

Parallel Scavenge收集器的老年版本

支持多线程并发收集

基于标记-整理算法

在注重吞吐量或者处理器资源稀缺的场合，可以优先考虑Parallel Scavenge搭配Parallel Old收集器。

![截屏2023-09-25 20.04.57](/Users/yinglibo/Documents/typora/截屏2023-09-25 20.04.57.png)

### CMS收集器

Concurrent Mark Sweep（CMS）

CMS收集器的目标：获取最短回收停顿时间

基于标记-清除算法

运行过程：

1. 初始标记：标记GC Roots能直接关联到的对象，速度很快，需要停止用户线程
2. 并发标记：从GC Roots直接关联的对象开始遍历整个对象图，这个阶段耗时长，但是不停止用户线程
3. 重新标记：修正并发标记期间，由于用户程序继续运行导致的标记变化的对象记录，耗时比1多，但是比2少
4. 并发清除：清除标记死亡的对象。不需要移动存活的对象，可以与用户线程并发

1.3.这两个步骤需要停止用户程序（stop the world），2.4.这两步耗时长但是可以和用户线程并发。所以从整体上讲，CMS内存回收的过程可以和用户程序并发执行。

![截屏2023-09-25 20.21.01](/Users/yinglibo/Documents/typora/截屏2023-09-25 20.21.01.png)

CMS收集器的优点：并发收集、低停顿

缺点：

- CMS收集器对处理器资源非常敏感（并发阶段，虽然不会暂停用户线程，但是由于占用了一部分的线程，会导致应用程序变慢，降低总吞吐量），特别是在处理器核心数不足4个时（处理器核心数量大于等于4时，默认使用1/4的线程用于垃圾收集）
- 无法处理“浮动垃圾”，进而可能出现并发失败，导致出现一次“stop the world”的Full GC，（浮动垃圾：在CMS的并发标记和并发清除阶段产生的留待下一次垃圾收集（没有标记上）在清理掉的垃圾）    在并发阶段需要留足够的内存给用户进程使用，空间如果不够就会出现“并发失败”，此时启动备用方案：暂停用户线程，启用Serial Old收集器来进行老年代垃圾收集，这样停顿时间变长了。
- 基于标记-清除算法---->大量内存碎片

### G1(Garbage First)收集器

垃圾收集器发展史上的里程碑式的成果，开创了收集器面向局部收集的设计思想和基于Region的内存布局形式。

面向服务器端应用

在JDK9发布时，成为服务器端默认的垃圾收集器

**基于Region的堆内存布局**：把连续的JAVA堆划分为多个大小相等的独立区域，每个区域(region)可以根据需要扮演新生代的Eden空间、Survivor空间，或者老年代空间。根据扮演不同角色的区域采用不同的垃圾回收策略（不再坚持固定大小，固定数量的分代区域划分）

Region中还有一类特殊的Humongous区域，用来存储大对象（超过一个Region一半的对象），超过一个Region的对象存储在N个连续的Humongous region中

G1保留了新生代和老年代的概念，但是新生代和老年代不是固定的。将Region作为单次回收的最小单位，每次回收的内存都是Region的整数倍，这样避免了在整个java堆中进行全区域的垃圾收集。在后台维护一个优先级列表，记录了每个Region中垃圾被回收的价值（所得空间以及回收所需时间），每次根据用户设定允许的收集停顿时间，优先回收价值收益大的Region。

<img src="./image/截屏2023-09-26 19.34.41.png" alt="截屏2023-09-26 19.34.41" style="zoom:33%;" />

G1收集器的运行过程：

- 初始标记：标记GC Roots能直接关联到的对象，修改TAMS指针的值，需要暂停用户线程，耗时很短，而且是在进行Minor GC的时候同步完成，G1在此阶段没有额外的停顿

- 并发标记：从GC Roots开始对堆中的对象进行可达性分析，找出要回收的对象，耗时长，但是和用户线程并发进行。扫描完成后，重新处理记录SATB记录下在并发时有引用变动的对象。

- 最终标记：短暂的暂停用户线程，处理并发阶段结束后留下的少量的SATB记录

- 筛选回收：对各Region的回收价值和成本进行排序，根据用户期望的停顿时间制定回收计划。把要回收的Region的存活对象复制到新的Region中，然后清理旧的Region的空间（涉及对象的移动，需要暂停用户线程）。

  <img src="./image/截屏2023-09-26 20.00.26.png" alt="截屏2023-09-26 20.00.26" style="zoom:50%;" />

优点：

- G1收集器可以指定期望的停顿时间（合适的值，可以实现吞吐量和延迟之间的平衡）

- G1运行期间不会产生内存碎片，垃圾收集完成后可以提供规整的可用内存（整体基于标记-整理算法，两个Region之间基于标记-复制算法）

缺点：G1收集器垃圾收集的时候产生的内存占用，运行时的额外执行负载比CMS高

## 低延迟垃圾收集器

衡量垃圾收集的指标：内存占用，吞吐量，**延迟**

随着硬件的发展，性能的提升，内存占用和吞吐量会更高，但是硬件的提升（比如：内存的扩大），延迟更高

### Shenandoah收集器

目标：在任何堆内存大小下都可以把垃圾收集的停顿时间限制在10毫秒之内。

不仅要进行并发的垃圾标记，还有并发的进行对象清理后的整理工作。

同G1一样基于Region的堆内存布局，存放大对象的Humongous Region，默认回收策略是优先回收价值大的Region。

和G1的三个不同：

- 支持并发的整理算法

- 目前，默认不支持分代收集
- 抛弃了在G1中耗费大量内存和计算资源来维护的记忆集，该为连接矩阵（二维矩阵），比如Region N有对象指向Region M，那么在矩阵的N行M列打上标记。

工作过程：

- 初始标记：与G1一样，首先标记与GC Roots直接关联的对象，需要暂停用户线程，但是停顿的时间和堆的大小无关，只与GC Roots的数量有关
- **并发标记**：与G1一样，遍历对象图，标记全部可达对象，与用户线程并发，时间取决于堆中存活对象的数量以及对象图的结构复杂程度
- 最终标记：与G1一样，处理剩余的SATB扫描，统计回收价值最高的Region，将这些Region构成一个回收集。有很短暂的一段停顿。
- 并发清理：清理没有存活对象的Region（这些Region被称为immdiate garbage region）
- **并发回收**：该阶段与之前HotSpot中的回收器有很大的差异。先将回收集中的存活对象复制到未使用的Region中，复制的过程中用户进程依然可以访问被移动的对象，复制之后，内存中指向该对象的引用还是旧对象的地址。Shenandoah采用**读屏障**和**"Brooks Pointers"转发指针**来解决。该阶段时间取决于回收集的大小。 
- 初始引用更新：建立线程集合点，确保并发回收阶段中的收集器线程都完成了分配给他们的对象移动任务。该阶段会产生很短暂的停顿。
- **并发引用更新**：将堆中指向旧对象的引用修正到复制后的新地址（引用更新），该阶段与用户线程并发，时间取决于涉及的引用数量，按照内存物理地址的顺序，线性的搜索出引用类型，将旧的地址改成新的地址即可。
- 最终引用更新：修正存在于GC Roots中的引用，产生的停顿时间与GC Roots的数量相关。
- 并发清理：调用并发清理过程来回收immdiate garbage region。![](/Users/yinglibo/Documents/typora/截屏2023-09-27 16.22.00.png)

**并发回收的核心“转发指针”：**

在原有的对象布局结构的最前面添加一个新的引用字段（在对象头前面），不处于并发移动的情况下，该对象指向自己。

转发指针的工作原理如下：

1. Shenandoah将要移动的对象复制到新的内存位置。
2. Shenandoah在原始对象的位置上留下一个转发指针，指向新的对象位置。
3. 当其他对象引用原始对象时，它们会通过转发指针找到新的对象位置。
4. 转发指针将让引用者无需知道对象已经移动，从而保持引用的正确性。

<img src="./image/截屏2023-09-27 16.50.02.png" alt="截屏2023-09-27 16.50.02" style="zoom: 50%;" />

缺点：每次对象访问会带来一次额外的转向开销

<img src="./image/截屏2023-09-27 16.45.55.png" alt="截屏2023-09-27 16.45.55" style="zoom:50%;" />

会出现多线程竞争的问题，比如并发写入，要保证写操作发生在复制的对象上，而不是写入到旧对象内存中。

Shenandoah收集器通过比较、交换（CAS）操作来保证并发时对象的访问正确性。

同时设置了读、写屏障



### ZGC收集器

在JDK11中加入的低延迟垃圾收集器

ZGC收集器的主要特征：基于Region内存布局的，不设置分代，使用读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理算法的，以低延迟为首要目标的垃圾收集器

ZGC的Region与Shenandoah不同，具有动态性（动态创建和销毁）以及动态的区域容量大小（x64下，ZGC的Region有大、中、小三种容量）

- 小型Region：2MB，放置小于256KB的小对象

- 中型Region：32MB，256KB～4MB的对象

- 大型Region：容量不固定，但是必须是2MB的整数倍，放置大于4MB的对象，每个大型Region只会存放一个大对象。大型Region的实际容量可能小于中型Region，最小容量为4MB。大型Region在ZGC的实现中不会被重分配，因为复制一个大对象的代价很昂贵。

  <img src="./image/截屏2023-09-27 21.12.25.png" alt="截屏2023-09-27 21.12.25" style="zoom: 50%;" />

**ZGC的核心问题：并发回收算法的实现**

采用了读屏障

采用了染色指针技术，直接将标记信息记在引用对象的指针上，可达性分析直接遍历“引用图”来标记“引用”

染色指针：直接将少量额外的信息存储在指针上的技术。

在linux中，64位的指针的高18位不可以用来寻址，ZGC将剩下的46位的高4位用来存储4个标记信息（表示其引用对象的三色标记状态、是否进入了重分配集------被移动过、是否只能通过finalize()方法才能被访问到），只有剩下的42位可以用来寻址，所以ZGC可以管理的内存不可以超过4TB

<img src="./image/截屏2023-09-28 17.01.05.png" alt="截屏2023-09-28 17.01.05" style="zoom:50%;" />

染色指针的三大优势：

- 当某个Region的存活对象都被移走之后，这个region就可以立即被释放和被重用，不必等待整个堆中所有指向该region的引用都被修正后才能清理。
- 可以大幅减少在垃圾收集过程中的内存屏障的使用数量（内存屏障，尤其是写屏障的作用：记录对象引用的变动情况），ZGC目前只有读屏障，没有写屏障（原因：使用了染色指针；ZGC不支持分代收集，没有跨代引用的问题），省去内存屏障，可以降低对吞吐量的影响。
- 染色指针可以作为一种可扩展的存储结构来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提升性能。

使用染色指针的一个前提：操作系统支持JAVA虚拟机重新定义内存中的指针不同位置的含义。

Linux/x86-64平台上的ZGC使用了**多重映射**，将多个不同的虚拟内存地址（染色指针的标志位看作地址的分段符）映射到同一个物理内存地址上（多对一的映射），这意味着ZGC在虚拟内存中可见的地址空间比实际的堆内存容量更大。

![截屏2023-10-03 15.45.16](/Users/yinglibo/Documents/typora/截屏2023-10-03 15.45.16.png)

**ZGC的运行过程：**

- 并发标记：遍历对象图做可达性分析。在并发标记的前后也有初始标记、最终标记的短暂停顿，这和G1，Shenandoah一样，但是ZGC标记的是指针而不是对象本身。标记阶段会更新染色指针中的Marked0、Marked1标记位。
- 并发预备重分分配：根据特定的查询条件统计出本次收集过程要清理的Region，将这些Region组成重分配集。ZGC划分Region的目的不是像G1一样做收益优先的增量回收，ZGC每次回收都会扫描所有的Region（不是只针对重分配集的Region做回收），ZGC的重分配集只是决定了在该集合中的存活对象会被复制到其他的Region中，里面的Region会被释放。
- 并发重分配：核心阶段，将重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（记录从旧对象到新对象的转向关系）。ZGC收集器仅从引用上就可以知道一个对象是否处于重分配集中（染色指针的支持）。如果用户线程此时访问了位于重分配集中的对象，本次的访问会被预置的内存屏障截获，并根据Region上的转发表将访问转发到新复制的对象上，并且修复该引用的值，使其指向新对象（指针“自愈”）。**好处：**1. 只有第一次访问旧对象会转发，只慢一次。2. 重分配集中某个Region存活的对象被复制完毕后，这个Region就可以立即释放用于新对象的分配（转发表不能释放，用于访问旧对象时，指针自愈）
- 并发重映射：修正整个堆中指向重分配集中旧对象的所有引用。由于旧引用是可以自愈的，所以这个阶段不是很紧迫，ZGC将该阶段合并到了下一次垃圾收集过程中的并发标记阶段。这个阶段也需要遍历所有的对象，与并发标记一样，两个阶段合并起来可以节省一次遍历对象图的开销。该阶段完成后，可以释放旧对象关系的转发表。



ZGC的收集过程几乎全程可以并发，短暂的停顿只与GC Roots大小相关，与堆内存大小无瓜



## 选择合适的垃圾收集器

垃圾收集器的工作：

- 垃圾收集
- 堆的管理和布局、对象的分配、与解释器的协作、与编译器的协作、与监控子系统协作

### Epsilon收集器

不做垃圾收集的工作，无操作的收集器。

如果需要运行的应用只需要运行数分钟甚至数秒，只要JAVA虚拟机能正确分配内存，在堆耗尽之前退出，那么运行负载小、没有回收行为的Epsilon就是恰当的选择

### 收集器的权衡

如何选择适合自己应用的收集器：

- 应用程序的关注点：吞吐量，延迟，垃圾收集器的内存占用
- 运行应用的基本设施，比如硬件规格、系统架构、处理器的数量、分配内存的大小、操作系统
- JDK的发行商、版本号

### 虚拟机及垃圾收集日志

p123

### 垃圾收集器参数总结

P128

### 内存分配与回收策略

对象的内存分配从概念上都是在堆上的，实际上，有可能经过即时编译后被拆散成标量类型并且间接的在栈上分配。

新生的对象，一般分配在新生代中，少数情况下可能直接分配在老年代（比如对象的大小超过了一定的阈值）

- 大多数的情况下，新生的对象在新生代的Eden区中分配，当Eden区中没有足够的空间时，虚拟机将发起一次Minor GC。如果对象经过一次minor gc后依然存活，并且可以被survivor区容纳，该对象会移动到survivor区，并且年龄增加1。当年龄增加到一定程度的时候，就会被转移到老年代（第三条）；或者survivor空间中相同年龄的所有对象大小的总和大于survivor空间的一半，年龄大于或者等于该年龄的对象也直接进入老年代。

- 大对象（需要大量连续内存空间的java对象）直接在老年代中分配，这样可以避免在Eden区和两个Survivor区之间来回的复制，产生大量的内存复制操作

- 长期存活（根据存储在对象头中的对象年龄计数器）的对象将进入老年代

#### 空间分配担保：

在Minor GC之前，虚拟机需要检查老年代的最大可用的连续空间大于新生代所有对象总空间。

- 条件成立：本次Minor GC是安全的
- 条件不成立：虚拟机会查看参数-XX:HandlePromotionFailure参数是否允许担保失败
  - 允许：检查老年代的最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
    - 大于：尝试进行一次Minor GC
    - 小于：Full GC
   - 不允许：Full GC

在JDK 6 Update 24之后，参数-XX:HandlePromotionFailure参数已经不再使用，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则进行Full GC。

# 虚拟机性能监控、故障处理工具

在JAVA的bin目录下，比如java.exe,javac.exe。

## 基础故障处理工具

### jps:虚拟机进程状况工具

jps：虚拟机进程状况工具，可以显示正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID（LVMID）。对于本地虚拟机进程而言，LVMID和操作系统的进程ID（PID）是一致的。

jps的的命令格式：jps [options] [hostid]

选项：

- -q：只输出LVMID，省略主类的名称
- -m：输出虚拟机进程启动时传递给主类main()函数的参数
- -l：输出主类的全名，如果主类进程执行的是JAR包，输出JAR路径
- -v：输出虚拟机进程启动时的JVM参数

jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数hostid为RMI注册表中注册的主机名。

### jstat:虚拟机统计信息监视工具

作用：监视虚拟机各种运行状态信息的命令行工具，可以显示**本地或者远程**虚拟机进程中类的加载、内存、垃圾收集、即时编译等运行时数据。

jstat的命令格式为：jstat [option vmid [interval[s|ms] [count]]]

如果是本地虚拟机进程，vmid就是lvmid。

如果是远程虚拟机进程：vmid的格式为，\[protocal:][//]lvmid[@hostname[:port]/servername]

interval和count分别表示：查询间隔、总共查询次数

**例子**：每250毫秒查询一次进程2764垃圾收集状况，共查询20次

jstat -gc 2764 250 20

option：希望查询的虚拟机信息，主要分为三类，类加载、垃圾收集、运行期编译状况

**具体参数查看p142**

### jinfo：java配置信息工具

作用：查看和调整虚拟机各项参数

jinfo命令格式：

jinfo [option] pid

### jmap：java内存映像工具

生成堆转储快照文件的方法：

- jmap命令

- 参数-XX:+HeapDumpOnOutOfMemoryError让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件

- 参数- XX:+HeapDumpOnCtrlBreak可以使用Ctrl+break键让虚拟机生成堆转储快照文件

- Linux系统下通过Kill-3命令

jmap的作用：

- 获取堆转储快照文件

- 查询finalize执行队列、java堆和方法区的详细信息（如空间利用率、使用的收集器……）

jmap的功能在windows下受限，除了生成堆转储快照的-dump选项和查看每个类的实例、空间占用统计的-histo选项在所有的操作系统下都可以使用外，其余的选项都只能在linux/solaris中使用

jmap的格式：jmap [option] vmid

主要选项：

- -dump：生成java堆转储快照，格式为-dump:[live,]format=b,file=\<filename>

- -finalizerinfo：显示在F-Queue中等待Finalizer线程执行finalize方法的对象
- -heap：显示java堆详细信息，比如，使用哪种回收器、参数配置、分代状况
- -histo：显示堆中对象统计信息，包括类、实例数量、合计容量
- -permstat：以ClassLoader为统计口径显示永久代内存状态
- -F：当虚拟机进程对-dump选项没有响应时，可以使用-F强制生成dump快照。

### jhat：虚拟机堆转储快照分析工具

和jmap搭配使用，来分析jmap生成的堆转储快照，jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。

但是一般会采用更高级的工具来做堆转储快照文件的分析工作

### jstack：java堆栈跟踪工具

jstack作用：生成虚拟机当前时刻的线程快照（称为threaddump或者javacore文件）

线程快照：当前虚拟机内每条线程正在执行的方法堆栈的集合

生成线程快照的目的：定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起……

jstack命令格式：jstack [option] vmid

选项：

- -F：当正常输出的请求不被响应时，强制输出线程堆栈
- -l：除了显示堆栈外，显示过于锁的附加消息
- -m：调用本地方法的话，可以显示C/C++的堆栈

jdk 5起，java.lang.Thread类新增了方法getAllStackTraces()方法也可以获取虚拟机中所有线程的StackTraceElement对象。

![截屏2023-10-10 17.35.34](/Users/yinglibo/Documents/typora/截屏2023-10-10 17.35.34.png)